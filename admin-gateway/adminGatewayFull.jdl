application {
  config {
    baseName admin
    packageName com.monsterdam.admin
    applicationType gateway
    authenticationType jwt
    reactive false
    databaseType sql
    devDatabaseType h2Memory
    prodDatabaseType postgresql
    cacheProvider redis
    buildTool maven
    clientFramework react
    clientTheme minty
    clientThemeVariant primary
    enableHibernateCache true
    enableSwaggerCodegen true
    enableTranslation true
    nativeLanguage es
    languages [es, en, fr, de, pt-br, ru]
    testFrameworks [gatling, cypress]
    searchEngine elasticsearch
    messageBroker kafka
    clientPackageManager npm
    serviceDiscoveryType consul
    serverPort 8090
  }
  entities *
}


// --- Tablas y lógica de superUsuarios ---

// Detalles para el usuario administrativo

entity AdminUserProfile {
  fullName String required pattern(/^[a-z0-9_-]+$/)
  emailAddress String required pattern(/^[^@]+@[^@]+\.[^@]+$/)
  nickName String required pattern(/^[a-z0-9_-]{3,16}$/)
  gender AdminGender required
  mobilePhone String pattern(/^\+?[0-9]{10,15}$/)
  lastLoginDate Instant required
  birthDate LocalDate required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

enum AdminGender {

  //  Género masculino.
  MALE("user.gender.male"),

  // Género femenino.
  FEMALE("user.gender.female"),

  // Individuo que ha realizado una transición de hombre a mujer.
  TRANS_FEMALE("user.gender.trans-female"),

  // Individuo que ha realizado una transición de mujer a hombre.
  TRANS_MALE("user.gender.trans-male")
}

// Revisión de documentos por el administrador

entity IdentityDocumentReview {
  documentStatus DocumentStatus
  resolutionDate Instant
  reviewStatus ReviewStatus
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String

}

entity DocumentReviewObservation {
  commentDate Instant
  comment String required
}

entity IdentityDocument {
  documentName String required
  documentDescription String
  documentStatus DocumentStatus
  documentType DocumentType
 // fileDocument AnyBlob required   se comenta este campo porque en lugar de eso el documento se guardara en S3
  fileDocumentS3Key String required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String

}
// Los tickets de asistencia creados por usuarios o administradores

entity AssistanceTicket {
  subject String required
  description String required
  status TicketStatus required
  type TicketType required
  openedAt Instant
  closedAt Instant
  comments String
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
}

entity ModerationAction {
  actionType ModerationActionType required
  reason String maxlength(255)
  actionDate Instant
  durationDays Duration

}
// mi idea es mensajes como los de telegram, asi les llegan mensajes de anuncios, dados de alta y enviados en forma de mensaje por un Admin
// Crear el usuario de noticiero en Monsterdam, que podra enviar mensajes a todos como anuncios. y a ese user se asociara su chat.

entity AdminAnnouncement {
  announcementType AdminAnnouncementType required
  title String maxlength(100) required
  content String required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
}
enum TicketStatus {

  /* El ticket está abierto y esperando respuesta. */
  OPEN("admin.ticket.status.open"),

  /* El ticket ha sido asignado a un miembro del equipo. */
  ASSIGNED("admin.ticket.status.assigned"),

  /* El ticket ha sido cerrado. */
  CLOSED("admin.ticket.status.closed")
}

enum TicketType {

  /* Problemas de acceso a la cuenta. */
  ACCESS_ISSUE("admin.ticket.type.accessIssue"),

  /* Verificación de documentos para convertirse en creador. */
  DOCUMENT_VERIFICATION("admin.ticket.type.document.verification"),

  /* Solicitudes de reembolso. */
  REFUND_REQUEST("admin.ticket.type.refund.request"),

  /* Reportar contenido o comportamiento inapropiado. */
  REPORT_REQUEST("admin.ticket.type.report.request"),

  /* Otros problemas no categorizados. */
  OTHER("admin.ticket.type.other"),

  /* Problemas con el contenido (no carga, mala calidad, etc.). */
  CONTENT_ISSUE("admin.ticket.type.content.issue"),

  /* Problemas con transacciones o pagos. */
  PAYMENT_ISSUE("admin.ticket.type.payment.issue"),

  /* Denuncias de acoso o comportamiento inapropiado. */
  HARASSMENT_REPORT("admin.ticket.type.harassment.report"),

  /* Reportar fallos técnicos o errores en la plataforma. */
  BUG_REPORT("admin.ticket.type.bug.report"),

  /* Consultas sobre suspensiones o bloqueos de cuenta. */
  ACCOUNT_SUSPENSION("admin.ticket.type.account.suspension"),

  /* Inquietudes relacionadas con la privacidad o datos personales. */
  PRIVACY_CONCERN("admin.ticket.type.privacy.concern"),

  /* Sugerencias de nuevas características o mejoras. */
  FEATURE_REQUEST("admin.ticket.type.feature.request")
}

enum ModerationActionType {

  /* Advertencia al usuario sobre una infracción. */
  WARNING("admin.moderation.action.type.warning"),

  /* Bloqueo temporal del usuario. */
  TEMPORARY_BAN("admin.moderation.action.type.temporary_ban"),

  /* Bloqueo permanente del usuario. */
  PERMANENT_BAN("admin.moderation.action.type.permanent_ban"),

  /* Eliminación de contenido específico. */
  CONTENT_REMOVAL("admin.moderation.action.type.content_removal"),

  /* Otras acciones de moderación no especificadas. */
  OTHER("admin.moderation.action.type.other")
}

enum AdminAnnouncementType {

  /* Anuncio en forma de banner. */
  BANNER("admin.announcement"),

  /* Actualización del sistema o plataforma. */
  SYSTEM_UPDATE("admin.announcement.type.system_update"),

  /* Cambios en las políticas de la plataforma. */
  POLICY_CHANGE("admin.announcement.type.policy_change"),

  /* Alerta para la comunidad. */
  COMMUNITY_ALERT("admin.announcement.type.community_alert"),

  /* Otros anuncios no categorizados. */
  OTHER("admin.announcement.type.other")
}

enum DocumentStatus {

  /* El documento está pendiente de revisión. */
  PENDING("admin.document.status.pending"),

  /* El documento ha sido aprobado. */
  APPROVED("admin.document.status.approved"),

  /* El documento ha sido rechazado. */
  REJECTED("admin.document.status.rejected")
}

enum ReviewStatus {

  /* La revisión está en proceso. */
  REVIEWING("admin.review.status.reviewing"),

  /* La revisión ha sido aprobada. */
  APPROVED("admin.review.status.approved"),

  /* La revisión ha sido rechazada. */
  REJECTED("admin.review.status.rejected")
}

enum DocumentType {

  /* Verificación de identidad. */
  ID_VERIFICATION("admin.document.type.id_verification"),

  /* Contrato. */
  CONTRACT("admin.document.type.contract"),

  /* Otros documentos no especificados. */
  MISC("admin.document.type.misc")
}


entity UserReport {
  reportDescription String
  status ReportStatus required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  reportCategory ReportCategory required
}
enum ReportStatus {

  /* El reporte ha sido registrado y está pendiente de revisión. */
  PENDING("report.status.pending"),

  /* El reporte ha sido revisado por un administrador. */
  REVIEWED("report.status.reviewed"),

  /* Se ha tomado acción con respecto al reporte. */
  ACTION_TAKEN("report.status.action-taken"),

  /* El reporte ha sido descartado sin tomar acciones. */
  DISMISSED("report.status.dismissed")
}
enum ReportCategory {

  /* Reporte relacionado con una publicación. */
  POST_REPORT("admin.report.post"),

  /* Reporte relacionado con un comentario. */
  COMMENT_REPORT("admin.report.comment"),

  /* Reporte relacionado con un mensaje. */
  MESSAGE_REPORT("admin.report.message"),

  /* Reporte relacionado con contenido multimedia. */
  MULTIMEDIA_REPORT("admin.report.multimedia"),

  /* Reporte relacionado con un usuario. */
  USER_REPORT("admin.report.user")
}


relationship OneToMany {

  UserProfile{makedReports(reportDescription)} to UserReport{reporter required}, // reporterId Long required

  UserProfile{receivedReports(reportDescription)} to UserReport{reported required}, //  reportedId Long required
  // multimediaId Long
  VideoStory{reports} to UserReport{story(duration)},
  SingleVideo{reports} to UserReport{video(duration)},
  SinglePhoto{reports} to UserReport{photo(thumbnail)},
  SingleAudio{reports} to UserReport{audio(duration)},
  SingleLiveStream{reports} to UserReport{liveStream(thumbnail)},
  DirectMessage{reports} to UserReport{message(messageContent)}, //  messageId Long
  PostFeed{reports} to UserReport{post(postContent)}, // postId Long
  PostComment{reports} to UserReport{postComment(commentContent)} //   commentId Long
}

relationship OneToOne {
  AssistanceTicket{moderationAction} to ModerationAction,
  // en las cajas de mensajes se visualiza si es un validamos si es de admin se manda hasta arriba en los mensajes como anuncio.
  //    directMessageId Long required
  AdminAnnouncement{announcerMessage} to DirectMessage,
  UserReport{ticket required} to AssistanceTicket{report},
  IdentityDocumentReview{ticket required} to AssistanceTicket{documentsReview}
}
// Relaciones
relationship OneToMany {
  AdminUserProfile{assignedTickets} to AssistanceTicket{assignedAdmin},
  IdentityDocumentReview{documents} to IdentityDocument{review},
  IdentityDocumentReview{observations} to DocumentReviewObservation{review},
  AdminUserProfile{announcements} to AdminAnnouncement{admin required},
  UserProfile{assistanceTickets} to AssistanceTicket{user} //  userId Long required

}

// CONTABILIDAD Y FINANZAS

// contabilidad y finanzas


entity AccountingRecord {
  date Instant required
  description String required
  debit BigDecimal
  credit BigDecimal
  balance BigDecimal required
  accountType AccountingType required
}
enum AccountingType {
  ASSET,
  LIABILITY,
  EQUITY,
  REVENUE,
  EXPENSE
}

entity FinancialStatement {
  statementType StatementType required
  periodStartDate LocalDate required
  periodEndDate LocalDate required
  createdDate Instant required
}
enum StatementType {
  BALANCE_SHEET,
  INCOME_STATEMENT,
  CASH_FLOW
}

entity TaxDeclaration {
  year Integer required
  declarationType TaxDeclarationType required
  submittedDate Instant
  status TaxDeclarationStatus required
  totalIncome BigDecimal
  totalTaxableIncome BigDecimal
  totalTaxPaid BigDecimal
  supportingDocumentsKey String
}

entity Budget {
  year Integer required
  totalBudget BigDecimal required
  spentAmount BigDecimal
  remainingAmount BigDecimal
  budgetDetails String
}

entity Asset {
  name String required
  value BigDecimal required
  acquisitionDate LocalDate
  type AssetType required
}
enum AssetType {
  CURRENT,
  FIXED,
  INTANGIBLE
}

entity Liability {
  name String required
  amount BigDecimal required
  dueDate LocalDate
  type LiabilityType required
}
enum LiabilityType {
  CURRENT,
  LONG_TERM
}

enum TaxDeclarationType {
  INCOME_TAX,
  VAT,
  OTHER
}
enum TaxDeclarationStatus {
  DRAFT,
  SUBMITTED,
  PROCESSED
}

relationship ManyToMany {
  TaxDeclaration{accountingRecords} to AccountingRecord{taxDeclarations}
}
relationship ManyToMany {
  FinancialStatement{accountingRecords} to AccountingRecord{financialStatements}
}

relationship OneToOne {
  AccountingRecord{payment} to PaymentTransaction  // paymentId Long
}
relationship OneToMany {
  Budget{accountingRecords} to AccountingRecord{budget},
  Asset{accountingRecords} to AccountingRecord{asset},
  Liability{accountingRecords} to AccountingRecord{liability}
}
// TERMINA FINANZAS



//___________________fin admin----

// en teoria al tener el diseño completo de la generacion vamos a pasar todas las tablas y relaciones

// pondremos todas las tablas para que genere el front y el back pero el back solo se usara para pasar los dto a cada microservicio y mantener la funcionalidad de front completa.


// FInance

entity MoneyPayout {
  amount BigDecimal required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  withdrawStatus PayoutStatus required

}
enum PayoutStatus {

  /* El retiro de dinero está pendiente de procesar. */
  PENDING("money.withdraw.status.pending"),

  /* El retiro de dinero ha sido procesado. */
  PROCESSED("money.withdraw.status.processed"),

  /* El retiro de dinero ha sido rechazado. */
  DECLINED("money.withdraw.status.declined")
}

entity CreatorEarning {
  amount BigDecimal required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity SubscriptionBundle {
  amount BigDecimal min(0) max(1000) required
  duration Duration required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity PaymentTransaction {
  amount BigDecimal required
  paymentDate Instant required
  paymentStatus GenericStatus required
  paymentReference String maxlength(100)
  cloudTransactionId String maxlength(100)
}
enum GenericStatus {

  /* El estado genérico de una acción o solicitud está pendiente. */
  PENDING("generic.status.pending"),

  /* Una acción o solicitud ha sido completada. */
  COMPLETED("generic.status.completed"),

  /* Una acción o solicitud ha sido rechazada. */
  DECLINED("generic.status.declined"),

  /* Se ha procesado un reembolso. */
  REFUNDED("generic.status.refunded"),

  /* Una acción o solicitud ha sido cancelada. */
  CANCELED("generic.status.canceled")
}


entity OfferPromotion {
  freeDaysDuration Duration
  discountPercentage Float min(0) max(100)
  startDate LocalDate required
  endDate LocalDate required
  subscriptionsLimit Integer
  linkCode String required
  isFinished Boolean required
  promotionType OfferPromotionType required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}
enum OfferPromotionType {

  /* link de promo individual. */
  SPECIAL("offer.promotion.type.special"),

  /* link de promo individual. */
  TRIAL_LINK("offer.promotion.type.trial-link"),

  /* Promoción general de descuento. */
  DISCOUNT("offer.promotion.type.discount"),

  /* Promoción general de días gratuitos. */
  FREE_DAYS("offer.promotion.type.free-days")
}

entity PurchasedContent {
  rating Float
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity PurchasedSubscription {
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  endDate LocalDate required
  subscriptionStatus PurchasedSubscriptionStatus required
  // se sustituye con valores de la tabla relacion generada por el many to many
  viewerId Long required
  creatorId Long required
}

entity WalletTransaction {
  amount BigDecimal required
  lastModifiedDate Instant
  transactionType WalletTransactionType required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}
enum WalletTransactionType {

  /* Se ha añadido dinero a la cartera. */
  TOP_UP("viewer.wallet.transaction.type.deposit"),

  /* Se ha utilizado el saldo de la cartera para hacer una compra. */
  PURCHASE("viewer.wallet.transaction.type.purchase"),

  /* Se ha procesado un reembolso a la cartera. */
  REFUND("viewer.wallet.transaction.type.refund"),

  /* Se ha retirado dinero de la cartera, posiblemente para un caso de uso futuro. */
  WITHDRAWAL("viewer.wallet.transaction.type.withdrawal")
}

entity PurchasedTip {
  amount BigDecimal required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}
enum PurchasedSubscriptionStatus {

  /* Suscripción adquirida por primera vez. */
  PURCHASED("subscription.status.purchased"),

  /* Suscripción pendiente de procesar. */
  PENDING("subscription.status.pending"),

  /* La suscripción ha expirado. */
  EXPIRED("subscription.status.expired"),

  /* La suscripción ha sido cancelada. */
  CANCELLED("subscription.status.cancelled"),

  /* La suscripción ha sido suspendida. */
  SUSPENDED("subscription.status.suspended")
}

// mostrar cada mes al creador estadisticas de sus usuarios y pedirle que escoga a su usuario del mes, si no lo escoge se pone el que mas compro y debe darle un regalo si no se le da un descuento en su renovacion.
entity SpecialAward {
  startDate LocalDate required
  endDate LocalDate required
  reason String
  altSpecialTitle String
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  viewerId Long required
  creatorId Long required
  specialTitleId Long required
}
// regalo que se da al ganador del mes por sus compras y su numero de renovaciones o reacciones etc.
entity SpecialReward {
  description String required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  contentPackageId Long required
  viewerId Long required
  offerPromotionId Long required
}

relationship OneToOne {
  //pagos con tarjeta
  PurchasedTip{payment(amount)} to PaymentTransaction,
  PurchasedContent{payment(amount)} to PaymentTransaction,
  PurchasedSubscription{payment(amount)} to PaymentTransaction,
  WalletTransaction{payment(amount)} to PaymentTransaction, // recarga de wallet
  //compras con wallet
  PurchasedTip{walletTransaction(amount)} to WalletTransaction,
  PurchasedContent{walletTransaction(amount)} to WalletTransaction,
  PurchasedSubscription{walletTransaction(amount)} to WalletTransaction,

  //resultando en ganancias del creador
  PurchasedTip{creatorEarning(amount) required} to CreatorEarning,
  PurchasedContent{creatorEarning(amount) required} to CreatorEarning,
  PurchasedSubscription{creatorEarning(amount) required} to CreatorEarning,

  MoneyPayout{creatorEarning(amount) required} to CreatorEarning, //retiro del creador.


  //deben ser mas porque hay gifts de post tambien
  PurchasedTip{message(messageContent) required} to DirectMessage // messageId Long

}

relationship OneToMany {
  SubscriptionBundle{selledSubscriptions} to PurchasedSubscription{subscriptionBundle required},
  OfferPromotion{purchasedSubscriptions} to PurchasedSubscription{appliedPromotion(promotionType)},
  UserProfile{withdraws(amount)} to MoneyPayout{creator required}, //creatorId Long required
  UserProfile{subscriptionBundles(amount)} to SubscriptionBundle{creator required}, // creatorId Long required
  UserProfile{earnings(amount)} to CreatorEarning{creator required}, // creatorId Long required
  UserProfile{payments(amount)} to PaymentTransaction{viewer required}, // viewerId Long required
  UserProfile{planOffers(endDate)} to OfferPromotion{creator required}, // creatorId Long required
  UserProfile{purchasedContent} to PurchasedContent{viewer required}, // viewerId Long required
  UserProfile{purchasedSubscriptions} to PurchasedSubscription{viewer required}, // viewerId Long required
  UserProfile{wallet(amount)} to WalletTransaction{viewer required}, // viewerId Long required
  ContentPackage{selledPackages} to PurchasedContent{purchasedContentPackage required} //  contentPackageId Long required

}
relationship ManyToOne {

  PaymentTransaction{paymentMethod(methodName)} to PaymentMethod{payments(amount)}, //  paymentMethodId Long
  PaymentTransaction{paymentProvider(providerName)} to PaymentProvider{payments(amount)} //  paymentProviderId Long

}

//PRofile

entity UserLite {
//  thumbnail ImageBlob
  thumbnailS3Key String
  birthDate LocalDate required
  gender UserGender required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  nickName String required pattern(/^[a-z0-9_-]{3,16}$/)
  fullName String required pattern(/^[a-z0-9_-]+$/)
  contentPreference ContentPreference required

}
entity UserProfile {
  emailContact String required pattern(/^[a-z0-9_-]+$/)
//  profilePhoto ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
//  coverPhoto ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  profilePhotoS3Key String
  coverPhotoS3Key String
  mainContentUrl String
  mobilePhone String pattern(/^\+?[0-9]{10,15}$/)
  websiteUrl String pattern(/^[^@]+@[^@]+\.[^@]+$/)
  amazonWishlistUrl String pattern(/^[^@]+@[^@]+\.[^@]+$/)
  lastLoginDate Instant required
  biography TextBlob
  isFree Boolean
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

enum ContentPreference {

  //  Preferencia por todo tipo de contenido.
  ALL("content.preference.all"),

  // Preferencia por contenido heterosexual.
  STRAIGHT("content.preference.straight"),

  // Preferencia por contenido homosexual.
  GAY("content.preference.gay"),

  // Preferencia por contenido relacionado con personas transgénero.
  TRANS("content.preference.trans")
}
enum UserGender {

  //  Género masculino.
  MALE("user.gender.male"),

  // Género femenino.
  FEMALE("user.gender.female"),

  // Individuo que ha realizado una transición de hombre a mujer.
  TRANS_FEMALE("user.gender.trans-female"),

  //  Individuo que ha realizado una transición de mujer a hombre.
  TRANS_MALE("user.gender.trans-male")
}


entity UserSettings {
  lastModifiedDate Instant
  darkMode Boolean required
  language UserLanguage required
  contentFilter Boolean required
  messageBlurIntensity Integer
  activityStatusVisibility Boolean required
  twoFactorAuthentication Boolean required
  sessionsActiveCount Integer
  emailNotifications Boolean required
  importantSubscriptionNotifications Boolean required
  newMessages Boolean required
  postReplies Boolean required
  postLikes Boolean required
  newFollowers Boolean required
  smsNewStream Boolean required
  toastNewComment Boolean required
  toastNewLikes Boolean required
  toastNewStream Boolean required
  siteNewComment Boolean required
  siteNewLikes Boolean required
  siteDiscountsFromFollowedUsers Boolean required
  siteNewStream Boolean required
  siteUpcomingStreamReminders Boolean required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}
enum UserLanguage {

  //  Idioma español.
  ES("user.language.es"),

  // Idioma inglés.
  EN("user.language.en"),

  // Idioma francés.
  FR("user.language.fr"),

  // Idioma alemán.
  DE("user.language.de"),

  // Idioma portugués (Brasil).
  PT_BR("user.language.pt_br"),

  // Idioma ruso.
  RU("user.language.ru")
}


entity UserAssociation {
  requestedDate Instant required,
  status AssociationStatus,
  associationToken String required,
  expiryDate Instant required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}
enum AssociationStatus {

  /* Indica que se ha solicitado una asociación. */
  REQUESTED("association.status.requested"),

  /* La solicitud de asociación ha sido aprobada. */
  APPROVED("association.status.approved"),

  /* La solicitud de asociación ha sido rechazada. */
  REJECTED("association.status.rejected")
}


entity UserEvent {
  title String required
  description TextBlob required
  startDate LocalDate required
  endDate LocalDate required
  creatorEventStatus UserEventStatus
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}
enum UserEventStatus {

  /* El evento ha sido cancelado. */
  CANCELED("creator.event.status.canceled"),

  /* El evento está activo y en curso. */
  ACTIVE("creator.event.status.active"),

  /* El evento ha sido eliminado. */
  DELETED("creator.event.status.deleted")
}


entity BookMark {
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity Feedback {
  content String required
  feedbackDate Instant required
  feedbackRating Integer
  feedbackType FeedbackType
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}
enum FeedbackType {

  /* Se utiliza cuando un usuario quiere reportar un problema o fallo en la plataforma. */
  ERROR("feedback.type.error"),

  /* Se utiliza cuando un usuario propone una mejora o sugiere una nueva característica. */
  SUGGESTION("feedback.type.suggestion"),

  /* Se utiliza para categorizar comentarios positivos sobre el servicio o plataforma. */
  PRAISE("feedback.type.praise"),

  /* Para comentarios o consultas que no encajan en las categorías anteriores. */
  OTHER("feedback.type.other")
}


entity PersonalSocialLinks {
//  thumbnail ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
//  normalImage ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  normalImageS3Key String
  thumbnailIconS3Key String
  socialLink String required unique
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity AppNotification {
    readDate Instant
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String
    isDeleted Boolean required
    // ManyToOne AppNotification{comment(commentContent)} to PostComment{commentNotifications(readDate)},
    postCommentId Long
    // ManyToOne AppNotification{post(postContent)} to PostFeed{postNotifications(readDate)},
    postFeedId Long
    // ManyToOne AppNotification{message(messageContent)} to DirectMessage{messageNotifications(readDate)},
    directMessageId Long
    //UserProfile{commentNotifications(createdDate)} to AppNotification{commentedUser required},
    //UserProfile{messageNotifications(createdDate)} to AppNotification{messagedUser required},
    targetUserId Long
    // ManyToOne AppNotification{userMention(postContent)} to UserMention{userMentionNotifications(readDate)},
    likeMark Long

    //UserProfile{userMentionNotifications(createdDate)} to AppNotification{mentionerUserInPost required},
    //UserProfile{commentMentionNotifications(createdDate)} to AppNotification{mentionerUserInComment required},

}
relationship OneToOne {
  //para relacionar de manera real al usuario en la administracion
  UserProfile{userLite required} to UserLite
  UserProfile{settings required} to UserSettings
}
relationship ManyToOne {
  UserProfile{countryOfBirth(name)} to Country, // countryOfBirthId Long
  UserProfile{stateOfResidence(stateName)} to State, // stateOfResidenceId Long

  BookMark{post(postContent) required} to PostFeed{bookMarks(createdDate)}, // postId Long
  BookMark{message(messageContent) required} to DirectMessage{bookMarks(createdDate)}, //  messageId Long

  PersonalSocialLinks{socialNetwork(thumbnail)} to SocialNetwork, // socialNetworkId Long


}
relationship OneToMany {
  // UserProfile{blockedUbications} to BlockedUbication{user required},
  UserProfile{socialNetworks} to PersonalSocialLinks{user required},
  UserProfile{commentNotifications(createdDate)} to AppNotification{targetUser required},
  UserProfile{messageNotifications(createdDate)} to AppNotification{targetUser required},
  UserProfile{userMentionNotifications(createdDate)} to AppNotification{mentionerUserInPost required},
  UserProfile{commentMentionNotifications(createdDate)} to AppNotification{mentionerUserInComment required},

  UserProfile{ownAccountsAssociations} to UserAssociation{owner required}, //  ownerId Long required
  UserProfile{createdEvents(title)} to UserEvent{creator required}, // creatorId Long required
  UserProfile{bookMarks(createdDate)} to BookMark{user required}, //  userId Long
  UserProfile{feedback(feedbackRating)} to Feedback{creator required}, //  creatorId Long required
}
relationship ManyToMany {
  UserProfile{followed} to UserProfile{followers},
  UserProfile{blockedList} to UserProfile{blockers},
  // la idea es meter la tabla SpecialAward en lugar de la tabla relacional y asi se tabla relacion con propiedades.
  UserProfile{loyaLists} to UserProfile{awards},
  // la idea es meter la tabla PurchasedSuscriptions en lugar de la tabla relacional y asi tener tabla relacion con propiedades.
  UserProfile{subscribed} to UserProfile{subscriptions},

  UserProfile{joinedEvents(startDate)} to UserEvent{members},
  UserProfile{blockedUbications} to State{blockers},
  PostFeed{hashTags} to HashTag{posts}, //  postFeedId Long
  UserProfile{hashTags} to HashTag{profiles}  // userId Long
}

//interactions



entity PostFeed {
  postContent TextBlob required
  isHidden Boolean
  pinnedPost Boolean
  likeCount Long
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity PostComment {
  commentContent TextBlob required
  likeCount Long
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity PostPoll {
  question TextBlob required
  isMultiChoice Boolean required
  lastModifiedDate Instant
  endDate LocalDate required
  PostPollDuration Duration required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity ChatRoom {
  lastAction String
  lastConnectionDate Instant
  muted Boolean
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity DirectMessage {
  messageContent TextBlob required
  readDate Instant
  likeCount Long
  isHidden Boolean
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}
entity ChatRoomGroup {
    creatorUserId Long
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String
    isDeleted Boolean required
    memberUserId Long
}

entity UserMention {
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

//entity UserTag {
//  createdDate Instant required
//  lastModifiedDate Instant
//  createdBy String
//  lastModifiedBy String
//  isDeleted Boolean required
//  tagStatus TagStatus required
//  // ManyToMany ContentPackage to UserProfile
//  contentPackageId Long required
//  taggedUserId Long required
//}
//enum TagStatus {
//  AUTHORIZED, // El usuario etiquetado ha autorizado la etiqueta.
//  PENDING, // La etiqueta está pendiente de autorización por el usuario etiquetado.
//  REJECTED // El usuario etiquetado ha rechazado la etiqueta.
//}


entity LikeMark {
  emojiTypeId Long required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
  // ManyToOne LikeMark{videoStory(duration) required} to VideoStory{likeMarks},
  // ManyToOne LikeMark{photo required} to SinglePhoto{likeMarks},
  // ManyToOne LikeMark{video(duration) required} to SingleVideo{likeMarks},
  multimediaId Long
  //OnetoMany LikeMark{message(messageContent) required} to DirectMessage{likeMarks},
  messageId Long
  //OnetoMany LikeMark{post(postContent) required} to PostFeed{likeMarks},
  postId Long
  // ManyToOne LikeMark{comment(commentContent) required} to PostComment{likeMarks}
  commentId Long
  // OneToMany
  //User{likedVideoStories} to LikeMark{storyLiker required},
  //User{likedComments} to LikeMark{commentLiker required},
  //UserInteractions{likedPhotos} to LikeMark{photoLiker required},
  //UserInteractions{likedVideos} to LikeMark{videoLiker required},
  //UserInteractions{likedMessages} to LikeMark{messageLiker},
  //UserInteractions{likedPosts} to LikeMark{postLiker required},
  likerUserId Long
}

entity HashTag {
  tagName String required
  hashtagType HashtagType required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

enum HashtagType {

  // Hashtag asociado a un usuario
  USER("hashtag.type.user"),

  // Hashtag asociado a un Post
  POST("hashtag.type.post"),

  // Hashtag asociado a un Fetiche
  FETISH("hashtag.type.fetish")

}

entity PollVote {
  createdDate Instant required

}

entity PollOption {
  optionDescription TextBlob required
  voteCount Integer required
}

relationship OneToOne {

  PostFeed{poll(question)} to PostPoll{post(postContent) required},

}
relationship OneToMany {

  PostFeed{comments(commentContent)} to PostComment{post(postContent) required},
  PostComment{responses(commentContent)} to PostComment{responseTo(commentContent)},
  DirectMessage{responses(messageContent)} to DirectMessage{responseTo(messageContent)},
  PostPoll{options(optionDescription)} to PollOption{poll(question) required},
  PostFeed{commentMentions(createdDate)} to UserMention{originPost(postContent)},
  PostComment{commentMentions(createdDate)} to UserMention{originPostComment(commentContent)}

  VideoStory{messages(messageContent)} to DirectMessage{repliedStory}, // repliedStoryId Long
  UserProfile{sentMessages(messageContent)} to DirectMessage{user required}, // senderUserId Long required
  UserProfile{chats(lastMessage)} to ChatRoom{user required}, //  participantUserId Long
  UserProfile{mentions} to UserMention{mentionedUser required}, // mentionedUserId Long required
  UserProfile{comments(commentContent)} to PostComment{commenter required}, // commenterUserId Long required
  UserProfile{feeds(postContent)} to PostFeed{creator required}, //  creatorUserId Long required

  UserProfile{votedPolls(createdDate)} to PollVote{votingUser}, //  votingUserId Long required

}
relationship ManyToOne {

  PollVote{pollOption(optionDescription) required} to PollOption{votes(createdDate)}
}
relationship ManyToMany {
  ChatRoom{sentMessages(messageContent)} to DirectMessage{chatRooms(lastAction)},

  ContentPackage{usersTagged} to UserProfile{contentPackageTags} // UserTagRelation
}

//multimedia



entity SingleAudio {
//  thumbnail ImageBlob required se comenta este campo porque en lugar de eso la imagen se guardara en S3
  thumbnailS3Key String required
 // content AnyBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  contentS3Key String required
  duration Duration
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity SingleVideo {
 // thumbnail ImageBlob required se comenta este campo porque en lugar de eso la imagen se guardara en S3
  thumbnailS3Key String required
 // content AnyBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  contentS3Key String required
  duration Duration
  likeCount Long
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity SinglePhoto {
//  thumbnail ImageBlob required se comenta este campo porque en lugar de eso la imagen se guardara en S3
  thumbnailS3Key String required
 // content ImageBlob maxbytes(2147483648) // 2GB for video, 5MB for photo, se comenta este campo porque en lugar de eso la imagen se guardara en S3
  contentS3Key String required
  likeCount Long
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity ContentPackage {
  amount BigDecimal
  videoCount Integer
  imageCount Integer
  isPaidContent Boolean required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity SingleDocument {
  title String required
  description String
//  documentFile AnyBlob required se comenta este campo porque en lugar de eso el documento se guardara en S3
  documentFileS3Key String required
  documentType String
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity VideoStory {
//  thumbnail ImageBlob required se comenta este campo porque en lugar de eso la imagen se guardara en S3
  thumbnailS3Key String required
//  content AnyBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  contentS3Key String required
  duration Duration
  likeCount Long
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity SingleLiveStream {
  title String
  description String
 // thumbnail ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  thumbnailS3Key String
  startTime Instant required
  endTime Instant
 // liveContent AnyBlob
  liveContentS3Key String
  isRecorded Boolean required
  likeCount Long
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}
relationship OneToOne {
  ContentPackage{audio} to SingleAudio{contentPackage required},

  DirectMessage{contentPackage} to ContentPackage{message(messageContent) required}, // messageId Long
  PostFeed{contentPackage} to ContentPackage{post(postContent) required}, // postId Long

}

relationship OneToMany {
  ContentPackage{videos(duration)} to SingleVideo{belongPackage(amount)},
  ContentPackage{photos} to SinglePhoto{belongPackage(amount)},

  UserProfile{videoStories(duration)} to VideoStory{creator required}, // creatorId Long required
  UserProfile{documents} to SingleDocument{user required}, // userId Long required

}

//CAtalogs

entity Country {
  name String required
  alpha2Code String required minlength(2) maxlength(2) // Ejemplo: 'MX' para México
  alpha3Code String required minlength(3) maxlength(3) // Ejemplo: 'MEX' para México
  phoneCode String
//  thumbnailCountry ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity State {
  stateName String required maxlength(100)
  isoCode String required maxlength(3)
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity SocialNetwork {
 // thumbnail ImageBlob se comenta este campo porque en lugar de eso la imagen se guardara en S3
  name String required maxlength(100) unique
  completeName String required unique
  mainLink String required unique
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required

}

entity EmojiType {
 // thumbnail ImageBlob required se comenta este campo porque en lugar de eso la imagen se guardara en S3
  description String required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}


entity PayoutMethod {
  methodName String required
  tokenText String required maxlength(100)
  expirationDate LocalDate
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity PaymentMethod {
  methodName String required
  tokenText String required maxlength(100)
  expirationDate LocalDate
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity PaymentProvider {
  providerName String required
  description String
  apiKeyText String required
  apiSecretText String required
  endpointText String required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}

entity SpecialTitle {
  description String
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}
entity TaxInfo {
  ratePercentage Float
  taxType TaxType required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}
enum TaxType {

  //Impuesto sobre el valor añadido.
  VAT("tax.type.vat"),

  // Retención en la fuente.
  WITHHOLDING("tax.type.withholding")
}

// Catalogos Sueltos Help

entity Currency {
  name String required
  symbol String required
  code String required minlength(3) maxlength(3)
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}


entity GlobalEvent {
  eventName String required
  startDate LocalDate required
  endDate LocalDate
  description String
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isDeleted Boolean required
}


entity HelpCategory {
  name String required unique
  isDeleted Boolean required

}


entity HelpSubcategory {
  name String required unique
  isDeleted Boolean required

}


entity HelpQuestion {
  title String required unique
  content TextBlob required
  isDeleted Boolean required

}


entity HelpRelatedArticle {
  title String required unique
  content TextBlob required

}

// Tabla de configuraciones generales.

entity AdminSystemConfigs {
  configKey String required maxlength(255)
  configValue String required
  description String maxlength(500)
  configValueType ConfigurationValueType
  configCategory ConfigurationCategory
  configFile AnyBlob
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isActive Boolean

}

enum ConfigurationValueType {

  // Valor de configuración en formato de cadena de texto
  STRING("configuration.value.type.string"),

  // Valor de configuración en formato numérico entero
  INTEGER("configuration.value.type.integer"),

  // Valor de configuración en formato booleano (verdadero/falso)
  BOOLEAN("configuration.value.type.boolean"),

  // Valor de configuración en formato de punto flotante.
  FLOAT("configuration.value.type.float"),

  // Valor de configuración en formato de fecha.
  DATE("configuration.value.type.date"),

  // Valor de configuración en formato JSON.
  JSON("configuration.value.type.json"),

  // Valor de configuración en formato de texto largo.
  TEXT("configuration.value.type.text")
}

enum ConfigurationCategory {

  // Configuraciones generales de la plataforma.
  GENERAL("configuration.category.general"),

  // Configuraciones relacionadas con la seguridad.
  SECURITY("configuration.category.security"),

  // Configuraciones de notificaciones.
  NOTIFICATIONS("configuration.category.notifications"),

  // Configuraciones de la interfaz de usuario.
  USER_INTERFACE("configuration.category.user_interface"),

  // Configuraciones relacionadas con métodos de pago.
  PAYMENT("configuration.category.payment"),

  // Configuraciones de integraciones externas.
  INTEGRATIONS("configuration.category.integrations"),

  // Configuraciones de contenido.
  CONTENT("configuration.category.content"),

  // Configuraciones de SEO.
  SEO("configuration.category.seo")
}

entity AdminEmailConfigs {
  title String required
  subject String required
  content String required
  mailTemplateType EmailTemplateType required
  createdDate Instant required
  lastModifiedDate Instant
  createdBy String
  lastModifiedBy String
  isActive Boolean required
}
enum EmailTemplateType {
  //  Notificaciones generales para el usuario, como alertas de actividad o actualizaciones.
  NOTIFICATION,
  // Boletines informativos con actualizaciones, noticias y contenido relevante para la comunidad.
  NEWSLETTER,
  // Alertas urgentes o importantes que el usuario debe conocer de inmediato.
  ALERT,
  // Promociones, descuentos o eventos especiales que se ofrezcan en la plataforma.
  PROMOTION

}

relationship ManyToOne {
  State{country(name) required} to Country,
  TaxInfo{country(name) required} to Country
}
relationship OneToMany {
  // Establece la relación entre Categoría y Subcategoría
  HelpCategory{subCategories} to HelpSubcategory{category}
  // Establece la relación entre Subcategoría y Pregunta
  HelpSubcategory{questions} to HelpQuestion{subcategory}
}
// Establece la relación entre Preguntas y Artículos Relacionados
relationship ManyToMany {
  HelpQuestion{question} to HelpRelatedArticle{relatedArticle}
}

search Country, State with elasticsearch



// finn de todos los microsericios



search Country, State, PostFeed, PostComment, DirectMessage, HashTag with elasticsearch

dto all with mapstruct

paginate PostFeed, PostComment, DirectMessage with infinite-scroll

paginate * with pagination except PostFeed, PostComment, DirectMessage

service * with serviceImpl
