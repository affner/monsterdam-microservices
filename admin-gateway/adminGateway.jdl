application {
    config {
        baseName admin
        packageName com.monsterdam.admin
        applicationType gateway
        authenticationType jwt
        reactive false
        databaseType sql
        devDatabaseType h2Memory
        prodDatabaseType postgresql
        cacheProvider redis
        buildTool maven
        clientFramework react
        clientTheme minty
        clientThemeVariant primary
        enableHibernateCache true
        enableSwaggerCodegen true
        enableTranslation true
        nativeLanguage es
        languages [es, en, fr, de, pt-br, ru]
        testFrameworks [gatling, cypress]
        searchEngine elasticsearch
        messageBroker kafka
        clientPackageManager npm
        serviceDiscoveryType consul
        serverPort 8090
    }
    entities *
}


// --- Tablas y lógica de superUsuarios ---

// Detalles para el usuario administrativo
entity AdminUserProfile {
    fullName String required pattern(/^[a-z0-9_-]+$/)
    emailAddress String required pattern(/^[^@]+@[^@]+\.[^@]+$/)
    nickName String required pattern(/^[a-z0-9_-]{3,16}$/)
    gender AdminGender required
    mobilePhone String pattern(/^\+?[0-9]{10,15}$/)
    lastLoginDate Instant required
    birthDate LocalDate required
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String
    isDeleted Boolean required

}

enum AdminGender {

    /* Género masculino. */
    MALE("user.gender.male"),

    /* Género femenino. */
    FEMALE("user.gender.female"),

    /* Individuo que ha realizado una transición de hombre a mujer. */
    TRANS_FEMALE("user.gender.trans-female"),

    /* Individuo que ha realizado una transición de mujer a hombre. */
    TRANS_MALE("user.gender.trans-male")
}

// Revisión de documentos por el administrador
entity IdentityDocumentReview {
    documentStatus DocumentStatus
    resolutionDate Instant
    reviewStatus ReviewStatus
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String

}
entity DocumentReviewObservation {
    commentDate Instant
    comment String required

}
entity IdentityDocument {
    documentName String required
    documentDescription String
    documentStatus DocumentStatus
    documentType DocumentType
//    fileDocument AnyBlob required  este campo no existira en db estara realmente en S3
    fileDocumentS3Key String required
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String

}
// Los tickets de asistencia creados por usuarios o administradores
entity AssistanceTicket {
    subject String required
    description String required
    status TicketStatus required
    type TicketType required
    openedAt Instant
    closedAt Instant
    comments String
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String
    // OneToMany  UserInteractions{assistanceTickets} to AssistanceTicket{user},
    userId Long required
}
entity ModerationAction {
    actionType ModerationActionType required
    reason String maxlength(255)
    actionDate Instant
    durationDays Duration
}
// mi idea es mensajes como los de telegram, asi les llegan mensajes de anuncios, dados de alta y enviados en forma de mensaje por un Admin
// Crear el usuario de noticiero en Monsterdam, que podra enviar mensajes a todos como anuncios. y a ese user se asociara su chat.
entity AdminAnnouncement {
    announcementType AdminAnnouncementType required
    title String maxlength(100) required
    content String required
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String
    //en las cajas de mensajes se visualiza si es un validamos si es de admin se manda hasta arriba en los mensajes como anuncio.
    //OneToOne  AdminAnnouncement{announcerMessage} to DirectMessage
    directMessageId Long required
}
enum TicketStatus {

    /* El ticket está abierto y esperando respuesta. */
    OPEN("admin.ticket.status.open"),

    /* El ticket ha sido asignado a un miembro del equipo. */
    ASSIGNED("admin.ticket.status.assigned"),

    /* El ticket ha sido cerrado. */
    CLOSED("admin.ticket.status.closed")
}

enum TicketType {

    /* Problemas de acceso a la cuenta. */
    ACCESS_ISSUE("admin.ticket.type.accessIssue"),

    /* Verificación de documentos para convertirse en creador. */
    DOCUMENT_VERIFICATION("admin.ticket.type.document.verification"),

    /* Solicitudes de reembolso. */
    REFUND_REQUEST("admin.ticket.type.refund.request"),

    /* Reportar contenido o comportamiento inapropiado. */
    REPORT_REQUEST("admin.ticket.type.report.request"),

    /* Otros problemas no categorizados. */
    OTHER("admin.ticket.type.other"),

    /* Problemas con el contenido (no carga, mala calidad, etc.). */
    CONTENT_ISSUE("admin.ticket.type.content.issue"),

    /* Problemas con transacciones o pagos. */
    PAYMENT_ISSUE("admin.ticket.type.payment.issue"),

    /* Denuncias de acoso o comportamiento inapropiado. */
    HARASSMENT_REPORT("admin.ticket.type.harassment.report"),

    /* Reportar fallos técnicos o errores en la plataforma. */
    BUG_REPORT("admin.ticket.type.bug.report"),

    /* Consultas sobre suspensiones o bloqueos de cuenta. */
    ACCOUNT_SUSPENSION("admin.ticket.type.account.suspension"),

    /* Inquietudes relacionadas con la privacidad o datos personales. */
    PRIVACY_CONCERN("admin.ticket.type.privacy.concern"),

    /* Sugerencias de nuevas características o mejoras. */
    FEATURE_REQUEST("admin.ticket.type.feature.request")
}

enum ModerationActionType {

    /* Advertencia al usuario sobre una infracción. */
    WARNING("admin.moderation.action.type.warning"),

    /* Bloqueo temporal del usuario. */
    TEMPORARY_BAN("admin.moderation.action.type.temporary_ban"),

    /* Bloqueo permanente del usuario. */
    PERMANENT_BAN("admin.moderation.action.type.permanent_ban"),

    /* Eliminación de contenido específico. */
    CONTENT_REMOVAL("admin.moderation.action.type.content_removal"),

    /* Otras acciones de moderación no especificadas. */
    OTHER("admin.moderation.action.type.other")
}

enum AdminAnnouncementType {

    /* Anuncio en forma de banner. */
    BANNER("admin.announcement"),

    /* Actualización del sistema o plataforma. */
    SYSTEM_UPDATE("admin.announcement.type.system_update"),

    /* Cambios en las políticas de la plataforma. */
    POLICY_CHANGE("admin.announcement.type.policy_change"),

    /* Alerta para la comunidad. */
    COMMUNITY_ALERT("admin.announcement.type.community_alert"),

    /* Otros anuncios no categorizados. */
    OTHER("admin.announcement.type.other")
}

enum DocumentStatus {

    /* El documento está pendiente de revisión. */
    PENDING("admin.document.status.pending"),

    /* El documento ha sido aprobado. */
    APPROVED("admin.document.status.approved"),

    /* El documento ha sido rechazado. */
    REJECTED("admin.document.status.rejected")
}

enum ReviewStatus {

    /* La revisión está en proceso. */
    REVIEWING("admin.review.status.reviewing"),

    /* La revisión ha sido aprobada. */
    APPROVED("admin.review.status.approved"),

    /* La revisión ha sido rechazada. */
    REJECTED("admin.review.status.rejected")
}

enum DocumentType {

    /* Verificación de identidad. */
    ID_VERIFICATION("admin.document.type.id_verification"),

    /* Contrato. */
    CONTRACT("admin.document.type.contract"),

    /* Otros documentos no especificados. */
    MISC("admin.document.type.misc")
}


entity UserReport {
    reportDescription String
    status ReportStatus required
    createdDate Instant required
    lastModifiedDate Instant
    createdBy String
    lastModifiedBy String
    isDeleted Boolean required
    reportCategory ReportCategory required
    // oneToMany UserInteractions{makedReports(reportDescription)} to UserReport{reporter required}
    reporterId Long required
    // ManytoOne UserReport{reported required} to UserInteractions{receivedReports(reportDescription)},
    reportedId Long required
    // UserReport{story(duration)} to VideoStory{reports(reportCategory)},
    multimediaId Long
    messageId Long
    postId Long
    commentId Long
}
enum ReportStatus {

    /* El reporte ha sido registrado y está pendiente de revisión. */
    PENDING("report.status.pending"),

    /* El reporte ha sido revisado por un administrador. */
    REVIEWED("report.status.reviewed"),

    /* Se ha tomado acción con respecto al reporte. */
    ACTION_TAKEN("report.status.action-taken"),

    /* El reporte ha sido descartado sin tomar acciones. */
    DISMISSED("report.status.dismissed")
}
enum ReportCategory {

    /* Reporte relacionado con una publicación. */
    POST_REPORT("admin.report.post"),

    /* Reporte relacionado con un comentario. */
    COMMENT_REPORT("admin.report.comment"),

    /* Reporte relacionado con un mensaje. */
    MESSAGE_REPORT("admin.report.message"),

    /* Reporte relacionado con contenido multimedia. */
    MULTIMEDIA_REPORT("admin.report.multimedia"),

    /* Reporte relacionado con un usuario. */
    USER_REPORT("admin.report.user")
}


relationship OneToMany {

    AdminUserProfile{announcements} to AdminAnnouncement{admin required}
}

relationship OneToOne {
    AssistanceTicket{moderationAction} to ModerationAction,

    UserReport{ticket required} to AssistanceTicket{report},
    IdentityDocumentReview{ticket required} to AssistanceTicket{documentsReview}
}
// Relaciones
relationship OneToMany {
    AdminUserProfile{assignedTickets} to AssistanceTicket{assignedAdmin},
    IdentityDocumentReview{documents} to IdentityDocument{review},
    IdentityDocumentReview{observations} to DocumentReviewObservation{review},
    AdminUserProfile{announcements} to AdminAnnouncement{admin required},

}

//___________________fin admin----

// en teoria al tener el diseño completo de la generacion vamos a pasar todas las tablas y relaciones

// pondremos todas las tablas para que genere el front poniendo skipfornt en todas las entidades que no sean admin, y asi tengamos un fron iniciado para el admin



//////// CONTABILIDAD Y FINANZAS

// contabilidad y finanzas

entity AccountingRecord {
    date Instant required
    description String required
    debit BigDecimal
    credit BigDecimal
    balance BigDecimal required
    accountType AccountingType required
    // AccountingRecord{payment} to Payment{accountingRecords}
    paymentId Long
}
enum AccountingType {
    ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE
}
entity FinancialStatement {
    statementType StatementType required
    periodStartDate LocalDate required
    periodEndDate LocalDate required
    createdDate Instant required
}
enum StatementType {
    BALANCE_SHEET, INCOME_STATEMENT, CASH_FLOW
}
entity TaxDeclaration {
    year Integer required
    declarationType TaxDeclarationType required
    submittedDate Instant
    status TaxDeclarationStatus required
    totalIncome BigDecimal
    totalTaxableIncome BigDecimal
    totalTaxPaid BigDecimal
    supportingDocumentsKey String
}
entity Budget {
    year Integer required
    totalBudget BigDecimal required
    spentAmount BigDecimal
    remainingAmount BigDecimal
    budgetDetails String
}
entity Asset {
    name String required
    value BigDecimal required
    acquisitionDate LocalDate
    type AssetType required
}
enum AssetType {
    CURRENT, FIXED, INTANGIBLE
}
entity Liability {
    name String required
    amount BigDecimal required
    dueDate LocalDate
    type LiabilityType required
}
enum LiabilityType {
    CURRENT, LONG_TERM
}

enum TaxDeclarationType {
    INCOME_TAX, VAT, OTHER
}
enum TaxDeclarationStatus {
    DRAFT, SUBMITTED, PROCESSED
}

relationship ManyToMany {
    TaxDeclaration{accountingRecords} to AccountingRecord{taxDeclarations},
    FinancialStatement{accountingRecords} to AccountingRecord{financialStatements}
}

relationship OneToMany {
    Budget{accountingRecords} to AccountingRecord{budget},
    Asset{accountingRecords} to AccountingRecord{asset},
    Liability{accountingRecords} to AccountingRecord{liability}
}
// TERMINA FINANZAS


//search  Country, State, PostFeed, PostComment, DirectMessage, HashTag with elasticsearch

dto all with mapstruct // except UserProfile

//paginate PostFeed, PostComment, DirectMessage with infinite-scroll

//paginate * with pagination except PostFeed, PostComment, DirectMessage

service * with serviceImpl
